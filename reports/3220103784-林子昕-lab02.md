## lab02-格式化字符串漏洞

### Task1

> 请阅读 fsb1.c 的内容，在本地和远程服务上完成攻击（要求getshell）。远程服务暴露在：
ip： 8.154.20.109 ，port： 10300

![alt text](img/3220103784-林子昕-lab02/image-1.png)

```shell
❯ echo "AAAAAAAA%p.%p.%p.%p.%p.%p.%p.%p" | ./fsb1
address of x is: 0x7ffd05b7a4f8
AAAAAAAA0x7ffd05b7a500.0x80.0x7f5cda7a17e2.0x20.0x7ffd05b7825c.(nil).0xbeaf.0x4141414141414141
```

得到 %7$p 的地址为 0xbeaf，根据 `fsb1.c` ，只需要修改 x 的值使它不等于 0xbeaf 即可。

构造 payload：

```text
测试时的布局：
[1] [2] [3] [4] [5] [6] [7:0xbeaf] [8:AAAAAAAA]

payload的布局：

格式化字符串部分 │ 填充部分     │ 地址部分
"%1c%9$hn\x00"  │ \x00\x00... │ x_addr
```


### Task2

> 请阅读 fsb2.c 的内容，在本地和远程服务上完成攻击（要求getshell）。远程服务暴露在：`ip： 8.154.20.109 ，port： 10301`
攻击步骤：
通过泄露libc函数来确定libc加载的虚拟地址，并通过计算拿到system的地址；
覆盖printf的GOT表为system；
调用printf以触发system从而getshell。
你可以通过学习pwntools中fmtstr 库的相关API来简化攻击流程。


### bonus

> 请阅读 bonus.c 的内容，在本地和远程服务上完成攻击（要求getshell）。远程服务暴露在：`ip： 8.154.20.109 ，port： 10302`
提示：
本题目中字符串不再位于栈上，无法利用之前的方法覆盖任意地址的内存。但栈上一些敏感内存仍然可以被覆盖，比如函数执行 push rbp 保存
的rbp寄存器。

